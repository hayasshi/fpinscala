# 14.3 純粋性とコンテキスト

---
参照透過性の定義

`式eがあり、すべてのプログラムpにおいて、pの意味に影響を与えることなく、p内のすべてのeをeの評価結果と置き換えることができるとしたら、eは参照透過である。`

---
下記の`Foo("hello")`副作用はあるか。

```scala
case class Foo(s: String)
val a = Foo("hello") == Foo("hello") // true
val b = Foo("hello") eq Foo("hello") // false
```

---
ある!

```scala
case class Foo(s: String)
val x = Foo("hello")
val a = x == x // true
val b = x eq x // true
```

---
したがって、参照透過性の最初の定義によれば、Scalaのすべてのデータコンストラクタに副作用があることになる。

それは新しい一意なオブジェクトがメモリ内に作成され、データコンストラクタがその新しいオブジェクトの参照を返すことである。

---
しかし、ほとんどのプログラムでは、これはどうでもよいこと。

=> ほとんどのプラグラムのコンテキストでは、副作用でも何でもない。

---
いままで紹介してきた参照透過の定義には、この点の考慮がされていないので、

下記のように再定義する。

- 式eがあり、すべてのプログラムpにおいて、pの意味に影響を与えることなく、p内のすべてのeをeの評価結果と置き換えることができるとしたら、eは参照透過である。

↓

- 式eがあり、プログラムpの意味に影響を与えることなく、p内のすべてのeをeの評価結果と置き換えることができるとしたら、eはpに関して参照透過である。

---
「評価」とはなにか

Scalaにはある程度標準的な答えがある。

```scala
val v = e  // 式eをScalaの正規形として強制的に評価する
```

プログラムpに関するeの参照透過性とは、p内のeを1つ残らずvに置き換えたとしても、プログラムの意味が変わらないことを意味する。

---
「プログラムの意味が変わる」とはどういう意味か

コンテキストによって決まる。このコンテキストを確立するのは選択。

=> プログラムに意味をもたせるのがプログラムのどの部分なのかを決定する。

=> プログラムのお気持ちを察する。

---
## 14.3.1 副作用とみなされるのはなにか

---
副作用に「気づく」ということ

```scala
def timesTwo(x: Int) = {
  if (x < 0) println("Got a negative number")
  x * 2
}
```

timesTwoには標準出力ストリームへのアクセスを要求するという、I/Oへの隠れた依存性がある。

---
しかし、この関数が純粋関数になるかどうかは、コンテキストによって変わってくる。

- UNIXのコマンドラインユーティリティのように、プログラムの正しいふるまいがコンソールに出力される内容に何らかの方法で依存する場合
  - そのプログラムにおいては非純粋関数である(副作用があるとみなされる)
- プログラムの正しいふるまいがコンソールに出力される内容に何らかの方法で依存しない場合
  - そのプログラムにおいては純粋関数である(副作用があるとみなされない)

---
Scala 関数型デザイン&プログラミング p331

```
要するに、基本的にはこういうことです——作用の追跡は私たちがプログラマとして下す選択です。
それは価値判断であり、どのように選択するかに関してトレードオフが存在します。
それをどう判断するかはあなた次第ですが、参照透過性の場合と同様に、Scalaにはある意味基準となる選択が存在します。
たとえば、メモリ割り当てを型システムで追跡することが私たちにとって本当に重要であるとしたら、そうすることは可能であり、まったく妥当な判断です。
しかし、Scalaでは自動的なメモリ管理を利用するため、通常は明示的な追跡のコストがそのメリットを上回ってしまいます。

ですから、プログラムの正しさの基準となる作用を追跡することをポリシーとすべきです。
プログラムが基本的にファイルの読み書きに関するものである場合は、型システムで実行可能な範囲でファイルI/Oを追跡すべきです。
プログラムがオブジェクト参照の等価性に依存する場合は、それを静的に知ることもできれば好都合です。
静的な型情報により、どのような作用が関与しているのかが明らかになり、その情報に基づいて、
特定のコンテキストでそれらが重要であるかどうかを消去法で判断できるようになります。
```

---
# 14.4 まとめ

---
Scala 関数型デザイン&プログラミング p331

```
本章では、参照透過性の2つの意味について説明しました。

ローカルスコープから外に漏れないデータは変更しても問題がないことがわかりました。
一見すると、状態の変化は純粋関数と両立しないように思えるかもしれません。
しかし、ここまで見てきたように、純粋なインターフェイスを持ち、内部でローカルな状態を変化させるコンポーネントを記述することは可能であり、
Scalaの型システムを使って純粋性を保証できます。

また、何を副作用と見なすかは、実際にはプログラマまたは言語の設計者が下す選択であることについても説明しました。
関数が純粋であることについて話をしているとしたら、コンテキストはすでに選択されているはずです。
つまり、2つのものが等しいとはどういうことか、プログラムを実行するとはどういうことか、
そしてプログラムに意味を割り当てるときにどの作用を考慮に入れるかがすでに決定されているということです。
```
